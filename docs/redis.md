## Репликация

# Состояние репликации
redis-cli info replication
redis-cli --stat

# Переключение из слейва
redis-cli slaveof no one

# Настройка репликации

slaveof 78.155.202.229 6379  # Адрес мастера
masterauth <pwd of master>   # Пароль мастера
slave-read-only yes          # Принимать запросы только на чтение
auto-aof-rewrite-percentage 100 # Выполнять автоматический BGREWRITEAOF когда AOF вырос на 100% с последнего раза
auto-aof-rewrite-min-size 128m  # Минимальный размер AOF когда BGREWRITEAOF может выполнятсья автоматически

config get client-output-buffer-limit
config set client-output-buffer-limit "slave 536870912 536870912 0"   # Буфер для slave 512Mb
config set client-output-buffer-limit "slave 1073741824 1073741824 0" # Буфер для slave 1Gb
config set client-output-buffer-limit "slave 1610612736 1610612736 0" # Буфер для slave 1.5Gb

info replication
client list

# Информация по памяти
redis-cli info memory

# Оптимизация AOF
redis-cli BGREWRITEAOF


# Запросы
Поиск по значению ключа: keys *<value>*
Получение типа значения: type <key>
string - GET <key>
hash - HGETALL <key>
lists - LRANGE <key> <start> <end>
sets = SMEMBERS <key>
sorted sets - ZRANGEBYSCORE <key> <min> <max>

# Описание работы репликации
Процесс синхронизации мастер-слейв:
1. Слейв при запуске или после потери коннекта обращается к мастеру с просьбой передать на слейв данные из базы мастера, что бы слейв мог начать обслуживать запросы клиентов
2. Мастер в ответ на этот запрос:

2.1. Создаёт дочерний процесс, который дампит базу Redis из памяти на диск в файл dump.rdb (см. fork() vs fork() vs clone())

2.2. в это время мастер продолжает отвечать на запросы от других клиентов

2.3. и любые данные, которые изменились этими клиентами с момента начала создания дампа сохраняет в буфер репликации

3. Мастер сообщает слейву, что дамп готов, и слейв начинает загружать его по сети к себе, сохраняя на диск

4. Слейв завершает передачу дампа к себе, загружает в память своего процесса Redis, и сообщает мастеру, что слейв готов к работе

5. Мастер проверят свой буфер, и если в нём есть данные — он передаёт изх на слейв, что бы тот заменил данные в своей базе, созданной из дампа, последними, актуальными данными

6. слейв применяет изменения, и вступает в работу

Таким образом, синхронизация мастер-слейв включает в себя два этапа:

1. Содаётся полная копия данных, которая может содержать устаревшие данные
2. Выполняется последовательный набор апдейтов из буфера, которые заканчвают приведение новой базы в состояние, аналогичное базе на мастере

# RDB
2 режима RDB:
1. Писать снапшор каждые N-минут
2. Писать снапшот каждые N-операций

Для создания RDB redis делает fork() и дочерний процесс формирует RDB. Дочерний процесс требует столько-же памяти сколько и родительский.
В процессе создания дампа redis не обслуживает пользователей (???)

# AOF
2 режима AOF:
1. Писать каждую секунду (by default)
2. Писать каждую операцию

Отсутствуют операции seek() внутри файла.
Встроенная утилита redis-check-aof которая может прочитать AOF и удалить не валидные операции из лога.
AOF не разрастается в размерах, есть параметр редиса, где указывается максимальный размер AOF. Как только файл достигнет максимума redis запустит процедуру уплотнения.
